<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <link href="prettify.css" type="text/css" rel="stylesheet" />
        <script type="text/javascript" src="prettify.js"></script>
        <link rel="stylesheet" href="melissa.css" />
        <title>Melissa</title>
    </head>

    <body onload="prettyPrint()">
        <nav id="navrow1" class="topmenu">
          <a href="index.html"><div id="melissa"><img src="latex/logo.png" alt="Melissa" title="Melissa" width="100%"/></div></a>
            <ul class="tablist">
            <li><a href="index.html"><span>About</span></a></li>
            <li><a href="getting_started.html"><span>Getting&#160;Started</span></a></li>
            <li class="current"><a href="documentation.html"><span>Documentation</span></a></li>
            <ul class="tablist2">
                <li><a class="active" href="#intro"><span>Introduction</span></a></li>
                <li><a class="" href="#api"><span>Melissa&#160;API</span></a></li>
                <li><a class="" href="#simu" id="simu_onglet"><span">Simulation</span></a></li>
                <li><a class="" href="#launcher"><span>Melissa&#160;Launcher</span></a></li>
                <li><a class="" href="#sbs"><span>Step-by-setp</span></a></li>
                <li><a class="" href="#dox"><span>Doxygen</span></a></li>
            </ul>
            <li><a href="gallery.html"><span>Gallery</span></a></li>
            <li><a href="contacts.html"><span>Contacts</span></a></li>
            <li><a href="https://github.com/melissa-sa/melissa" target="_blank"><span>Source</span></a></li>
            </ul>
        </nav>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="melissa">Melissa
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <nav id="navrow1" class="tabs">
  </nav>
        <div id="contener1">
        <section id="documentation_text" class="text">
        <h1 id="doc">documentation</h1><hr/>
          <p>
          </p>
            <h2 id="intro">Introduction</h2>
            <p>
              
              Melissa has a three tier architecture, and is based on a client/server model:
              <ul>
                <li> <code class="code">Melissa Server</code>: an independent parallel executable. It receives data from the simulations, updates iterative statistics as soon as possible, then discard the processed data.</li>
                <li> <code class="code">Melissa API</code>: a shared library to be linked within the numerical simulation solver. It forwards simulation data to Melissa Server.</li>
                <li> <code class="code">Melissa Master</code>: A Python script in charge of generating and managing the whole global sensitivity study.</li>
              </ul>
              <figure>
                <img src="src/workflow.png" alt="Melissa workflow" title="Melissa workflow" width="80%"/>
                <figcaption>Melissa Workflow on a Cluster</figcaption>
              </figure>
            Melissa can be used within a C or Fortran code, with or without MPI.
            Before reading this tutorial, select your favorite simulation type and language:
          </p>
      <div class="fieldsets">
        <fieldset class="lang" id="par">
          <legend>Simulation type</legend> <!-- Titre du fieldset -->
          <p>
            <input type="radio" name="MPI" value="nompi" id="MPI" checked/> <label for="MPI">MPI    </label><br />
            <input type="radio" name="MPI" value="mpi" id="noMPI" /> <label for="noMPI">No MPI</label><br />
          </p>
        </fieldset>
        <fieldset class="lang" id="lang">
          <legend>Simulation language</legend> <!-- Titre du fieldset -->
          <p>
            <input type="radio" name="lang" value="f" id="C" checked/> <label for="C">C</label><br />
            <input type="radio" name="lang" value="c" id="Fortran" /> <label for="Fortran">Fortran</label><br />
          </p>
        </fieldset>
      </div>
          <p>
              We will learn below how to link Melissa with the numerical simulation solver, and how to manage a sensitivity analysis through a very simple example.
          </p>
      <h2 id="api">Melissa API</h2>
      Melissa API is a library composed of tree functions, to be integrated in the solver:
        <ul>
          <li><code class="code">melissa_init</code></li>
          <li><code class="code">melissa_send</code></li>
          <li><code class="code">melissa_finalize</code></li>
        </ul>
      
      In order to use the Melissa functions, you have to link <code class="code"><span class="nompi">melissa_api_no_mpi</span><span class="mpi">melissa_api</span></code> and include <code class="code">melissa_api<span class="f">.f90</span><span class="c nompi">_no_mpi.h</span><span class="c mpi">.h</span></code> to your solver.
        <pre class="prettyprint c mpi"><code class="lang-c">
  #include &#60melissa_api.h&#62
        </code></pre>
        <pre class="prettyprint c nompi"><code class="lang-c">
  #include &#60melissa_api_no_mpi.h&#62
        </code></pre>
        <pre class="prettyprint f"><code class="lang-fortran">
  include "melissa_api.f90"
        </code></pre>
       
       
       <h3>
        <span class="mpi">
  melissa_init
        </span>
        <span class="nompi">
  melissa_init_no_mpi</span>
       </h3>
       <p>Prototype:</p>
        <pre class="prettyprint c mpi"><code class="lang-c">
  void melissa_init(const char *field_name,
                    const int  *local_vect_size,
                    const int  *comm_size,
                    const int  *rank,
                    const int  *simu_id,
                    MPI_Comm   *comm,
                    const int  *coupling);
        </code></pre>
        <pre class="prettyprint f mpi"><code class="lang-fortran">
  subroutine melissa_init(field_name,&
                          local_vect_size,&
                          comm_size,&
                          rank,&
                          simu_id,&
                          comm,&
                          coupling)
  character(kind=C_CHAR),dimension(*) :: field_name        
  integer                             :: local_vect_size
  integer                             :: comm_size
  integer                             :: rank
  integer                             :: simu_id
  integer                             :: comm
  integer                             :: coupling
        </code></pre>
        <pre class="prettyprint c nompi"><code class="lang-c">
  void melissa_init_no_mpi(const char *field_name,
                           const int  *vect_size,
                           const int  *simu_id,
                           const int  *coupling);
        </code></pre>
        <pre class="prettyprint f nompi"><code class="lang-fortran">
  subroutine melissa_init_no_mpi(field_name,&
                                 vect_size,&
                                 simu_id,&
                                 coupling)
  character(kind=C_CHAR),dimension(*) :: field_name   
  integer                             :: vect_size
  integer                             :: simu_id
  integer                             :: coupling
        </code></pre>
       
        variables:
        <ul>
          <li><code class="code">vect_size</code>: the size of the local result vector</li>
          <span class="mpi"><li><code class="code">comm_size</code>: the size of the local MPI communicator</li></span>
          <span class="mpi"><li><code class="code">rank</code>: the process rank in the local MPI communicator</li></span>
          <span><li><code class="code">simu_id</code>: the ID of the simulation in the study. This number is given by Melissa Launcher.</li></span>
          <span class="mpi"><li><code class="code">comm</code>: the local MPI communicator</li></span>
          <li><code class="code">coupling</code>: The way of coupling simulations in Sobol' groups. Macro defined by Melissa:
            <ul>
              <li><code class="code">MELISSA_COUPLING_ZMQ</code>: Coupling with ZeroMQ</li>
              <li><code class="code">MELISSA_COUPLING_MPI</code>: Coupling with MPI. Simulation code must suport MPMD mode.</li>
              <li><code class="code">MELISSA_COUPLING_FLOWVR</code>: Coupling with FlowVR. FlowVR must be installed.</li>
              <li><code class="code">MELISSA_COUPLING_DEFAULT</code>: Coupling with the default method (ZeroMQ for now).</li>
            </ul></li>
        </ul>
<!--        <ul>
          <li><code class="code">n</code>: the current iteration number</li>
          <li><code class="code">field_name</code>: the name of the field sent</li>
          <li><code class="code">u</code>: the vector to send to Melissa Server</li>
          <span class="mpi"><li><code class="code">me</code>: the process rank in the local MPI communicator</li></span>
          <li><code class="code">sobol_rank</code>: the rank of the simulation in the Sobol' group</li>
          <li><code class="code">sample_id</code>: the ID of the group in the study</li>
        </ul>-->
        <p>
        This function must be called once for each field to send to Melissa Server. The field names have to be declarated in the launcher option file, as we will see later.
        </p>
       <h3>
        <span class="mpi">
  melissa_send
        </span>
        <span class="nompi">
  melissa_send_no_mpi</span>
       </h3>
       
       
       <p>Prototype:</p>
        <pre class="prettyprint c mpi"><code class="lang-c">
  void melissa_send(const int  *time_step,
                    const char *field_name,
                    double     *send_vect,
                    const int  *rank,
                    const int  *simu_id);
        </code></pre>
        <pre class="prettyprint f mpi"><code class="lang-fortran">
  subroutine melissa_send(time_step,&
                          field_name,&
                          send_vect,&
                          rank,&
                          simu_id)
  integer                :: time_step
  character,dimension(*) :: field_name
  real*8,dimension(*)    :: send_vect
  integer                :: rank
  integer                :: simu_id
        </code></pre>
        <pre class="prettyprint c nompi"><code class="lang-c">
  void melissa_send_no_mpi(const int  *time_step,
                           const char *field_name,
                           double     *send_vect,
                           const int  *simu_id);
        </code></pre>
        <pre class="prettyprint f nompi"><code class="lang-c">
  subroutine melissa_send_no_mpi(time_step,&
                                 field_name,&
                                 send_vect,&
                                 simu_id)
  integer                :: time_step
  character,dimension(*) :: field_name
  real*8,dimension(*)    :: send_vect
  integer                :: simu_id
        </code></pre>
        variables:
       
        <ul>
          <li><code class="code">time_step</code>: statistics timestep</li>
          <li><code class="code">field_name</code>: the name of the field sent</li>
          <li><code class="code">send_vect</code>: the vector to send to Melissa Server</li>
          <span class="mpi"><li><code class="code">rank</code>: the process rank in the local MPI communicator</li></span>
          <li><code class="code">simu_id</code>: the ID of the simulation in the study, given by the launcher</li>
        </ul>
        <p>
        This function must be called at each time step that needs to be sent to Melissa Server, for each field. It can replace the IO phase of the code. The timestep sent to melissa is not the calculation timestep, but a timestamp incremented at each call to this function, for a given field. It must start at 1 (Fortran numbering).
        </p>
       <h3>
         melissa_finalize
       </h3>
       <p>Prototype:</p>
        <pre class="prettyprint c"><code class="lang-c">
  void melissa_finalize();
        </code></pre>
        <pre class="prettyprint f"><code class="lang-c">
  subroutine melissa_finalize();
        </code></pre>
        <p>
        <span class="nompi">Must be called at the end of the solver.</span>
        <span class="mpi">Must be called at the end of the solver, before <code  class="lang-c">MPI_Finalize</code>.</span>
        </p>
        
      <h2 id="launcher">Melissa Launcher</h2>
      <p>
        Once the simulation is instrumented, Melissa Launcher needs to know how to handle the simulation jobs.<br />
        This is done by giving the launcher some functions and variables through a python file.
        The file must be called <code class="code">options.py</code>. A empty template of this file is provided in <code class="code">share/launcher/options.py</code>. The options suported by Melissa are predefined in this file. The user must copy this file and modify it to meet his needs.
        There are four sets of variables to define, as dictionaries.
        <ul>
          <li><code class="code">STUDY_OPTIONS</code>: sets the parameters of your sensitivity study. They will be used by the launcher to generate its internal structures for the study management.</li>
          <li><code class="code">MELISSA_STATS</code>: are used to activate (or not) the iterative statistics.</li>
          <li><code class="code">USER_FUNCTIONS</code>: are pointers to user defined functions, used by the launcher. Some of them are optional, others are mandatory. We will describe these functions in this section.</li>
        </ul>
        Note that you can add fields to the option dictionaries, and they can be used in the user defined functions.
      </p>
      <h3>Functions</h3>
      Melissa Launcher needs the mandatory functions to be defined. Otherwise, it will return without runing the study.
      The optional functions are ignored if they are not defined by the user.<br />
      Note that the launcher sees simulations as "groups". In the case of classical statistics (i.e. not Sobol' indices), one group corresponds to one simulation. When Sobol' indices are required, simulations have to be launched by group, in the same job allocation.
      <ul>
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['create_study']</code> (optional):</pre></li>
        This function is called only once, before starting the study. It is called from the directory set in <code class="prettyprint lang-python">STUDY_OPTIONS['working_directory']</code>. You can use this function to create a folder tree, copy files, compile code, etc.
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['draw_parameter_set']</code> (mandatory):</pre></li>
        This function is used by Melissa launcher to draw simulations parameter sets. it must return a Numpy array of floats of the size <code class="prettyprint lang-python">STUDY_OPTIONS['nb_parameters']</code>
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['create_group']</code> (optional):</pre></li>
        This function is called once for each group in the study, before launching the study. Its behavior is the same as <code class="prettyprint lang-python">USER_FUNCTIONS['create_study']</code>.
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['launch_server']</code> (mandatory):</pre></li>
        After every simulation, group and parameter set is defined, Melissa Launcher uses this function to launch Melissa Server. The function takes a <code class="code">Server</code> object for argument, and needs to set the server job ID in <code class="code">server.job_id</code>.
        On a cluster the job ID is given by the batch scheduller. In your local machine, you can use the process ID. The server command line options are in <code class="code">server.cmd_opt</code>, you should not modify it.<br />
        An example for a Slurm cluster:
        <pre class="prettyprint"><code class="lang-python">
  import subprocess

  def launch_server(server):
      os.chdir(STUDY_OPTIONS['working_directory'])
      
      # create a job script
      fichier=open("run_server.sh", "w")
      contenu  = "#!/bin/bash \n"
      contenu  = "# Example with Slurm \n"
      contenu += "#SBATCH -N 4 \n"
      contenu += "#SBATCH --job-name=Melissa_server \n"
      contenu += "mkdir stats${SLURM_JOB_ID}.resu \n"
      contenu += "cd stats${SLURM_JOB_ID}.resu \n"
      contenu += "mpirun "+server.path+"/server "+server.cmd_opt+" & \n"
      contenu += "wait %1 \n"
      contenu += "cd "+workdir+" \n"
      fichier.write(contenu)
      fichier.close()
      
      # run the job script
      proc = subprocess.Popen('sbatch "./run_server.sh"',
                              stdout=subprocess.PIPE,
                              stderr=subprocess.PIPE,
                              shell=True,
                              universal_newlines=True)
                              
      # get the job ID
      (out, err) = proc.communicate()
      server.job_id = out.split()[-1]

  USER_FUNCTIONS['launch_server'] = launch_server
        </code></pre>
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['launch_group']</code> (mandatory):</pre></li>
        This function is used to launch simulations. The function takes a <code class="code">Group</code> object for argument, and needs to set the group job ID in <code class="code">group.job_id</code>.
        On a cluster the job ID is given by the batch scheduller. In your local machine, you can use the process ID.
        You have to copy the file called "server_name.txt" from the directory <code class="prettyprint lang-python">STUDY_OPTIONS['working_directory']</code> to the location where the simulations will run. The simulations will read it to retrieve the server node name in order to contact it.
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['check_server_job']</code> (mandatory):</pre></li>
        This function is called while the server is running. It checks the job's status in the scope of the fault tolerance mechanism.
        It takes a <code class="code">Job</code> object for argument, and needs to set <code class="code">job.job_status</code> to 1 if the job is still running, an to 2 otherwhise. A <code class="code">Server</code> object inherites from <code class="code">Job</code>, and the job ID is in <code class="code">job.job_id</code>.
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['check_group_job']</code> (mandatory):</pre></li>
        This function is called while a simulation is running. It checks the job's status in the scope of the fault tolerance mechanism.
        It takes a <code class="code">Job</code> object for argument, and needs to set <code class="code">job.job_status</code> to 1 if the job is still running, an to 2 otherwhise. A <code class="code">Simulation</code> object inherites from <code class="code">Job</code>, and the job ID is in <code class="code">job.job_id</code>.
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['cancel_job']</code> (mandatory):</pre></li>
        This function is called by the launcher when a job have to be canceled. It takes a <code class="code">Job</code> object for argument, and kills it.
        The job ID is defined in <code class="code">job.job_id</code>.<br />
        An example with a Slurm job:
        <pre class="prettyprint"><code class="lang-python">
  import os
  
  def cancel_job(job):
      os.system('scancel '+job.job_id)
      
  USER_FUNCTIONS['cancel_job'] = cancel_job
        </code></pre>
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['restart_server']</code> (optional):</pre></li>
        This function have the same behavior as <code class="prettyprint lang-python">USER_FUNCTIONS['launch_server']</code>. It is used to reboot the server in the case of a fault. If it is not defined, Melissa Launcher uses the <code class="prettyprint lang-python">launch_server</code> function by default.
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['restart_group']</code> (optional):</pre></li>
        This function have the same behavior as <code class="prettyprint lang-python">USER_FUNCTIONS['launch_group']</code>. It is used to reboot a simulation group in the case of a fault. If it is not defined, Melissa Launcher uses the <code class="prettyprint lang-python">USER_FUNCTIONS['launch_group']</code> function by default.
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['check_scheduler_load']</code> (optional):</pre></li>
        Melissa Launcher calls this function right before launching each simulation job. If it returns False, the launcher will not launch the simulation. Instead, il will wait one second, check the fault tolerance mechanism, and then retry until this function returns True.
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['postprocessing']</code> (optional):</pre>
        This function is called once at the end of the study. It does nothing by default.
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['finalize']</code> (optional):</pre></li>
        The same as <code  class="prettyprint lang-python">USER_FUNCTIONS['postprocessing']</code>.
      </ul>
      
      
<!--      ===================  -->
<!--      Sep by step example  -->
<!--      ===================  -->
      
      
     
      <h2 id="sbs">Step-by-step example</h2>
      <p>
        In this section, we will use a heat equation solver, available in the examples folder of melissa installation. You will find the code in <code class="prettyprint lang-bash">install/share/examples/heat_example/src</code>. The original solver is in the <span class="c"><code class="code">heat_base.c</code></span><span class="f"><code class="code">heat_base.f90</code></span> file. We will now edit and instrument this file step-by-step, in order to use it in the Melissa Framework. The final result must look like <span class="c mpi"><code class="code">heat.c</code></span><span class="f mpi"><code class="code">heat.f90</code></span><span class="c nompi"><code class="code">heat_no_mpi.c</code></span><span class="f nompi"><code class="code">heat_no_mpi.f90</code></span>, the "final" version of the solver. The corresponding final <code class="code">options.py</code> file is in the <code class="prettyprint lang-bash">install/share/examples/heat_example</code> directory. If you did the "testing" part of the <a href="getting_started.html">Getting Started</a>, you already ran it on your machine.
        </p>
      <h3 id="simu">Solver Instrumentation</h3>
        <p>
        To use the Melissa functions, we first have to include <code class="code">melissa_api<span class="f">.f90</span><span class="c nompi">_no_mpi.h</span><span class="c mpi">.h</span></code> at the begining of the code.
        <pre class="prettyprint c mpi"><code class="lang-c">
  #include &#60melissa_api.h&#62
        </code></pre>
        <pre class="prettyprint c nompi"><code class="lang-c">
  #include &#60melissa_api_no_mpi.h&#62
        </code></pre>
        <pre class="prettyprint f"><code class="lang-fortran">
  include "melissa_api.f90"
        </code></pre>
        Before calling Melissa functions in the code, we have to define a way to pass the simulation ID to the solver.
        Melissa Server will need it to identify which simulation sent the data.<br />
        The simulation ID is generated by the launcher, and available in the <code class="code">simu_id</code> atribute of the <code class="code">Group</code> object (for example <code class="code">group.simu_id</code>) in the python file  <code class="code">options.py</code>.
        In our case, we will pass that parameter to the simulation by adding arguments to the command line. We will see later how to handle it in the python side in more detail.<br />
        We store the simulation ID as an integer.
        </P>
        <p>
        In the case of Sobol' indices computation, we must also define the way simulations are connected inside a group. Melissa API provides some macros to pass the information to the <code class="prettyprint lang-c">melissa_init</code> function. We could hard-code it in the solver, but in this example we will pass it by command line, as an integer, like the simulation ID. We will describe later the possible values of this parameter.
        </P>
        <p>
        The solver can take from one to five input parameters, stored in five doubles, so the code to get the input parameters should look like this:
       
        <pre class="prettyprint c"><code class="lang-c">
  int simu_id  = 0;
  int coupling = MELISSA_COUPLING_DEFAULT;
  double param[5];

  if (argc < 4)
  {
      fprintf (stderr, "Missing parameter");
      return -1;
  }
  simu_id = (int)strtol(argv[1], NULL, 10);  // simulation ID
  coupling = (int)strtol(argv[2], NULL, 10); // coupling parameter

  for (n=0; n<5; n++)
  {
    param[n] = 0;
    if (argc > n+3)
    {
       param[n] = strtod(argv[n+3], NULL);
    }
  }
        </code></pre>
       
        <pre class="prettyprint f"><code class="lang-fortran">
  integer :: simu_id = 0, coupling = MELISSA_COUPLING_DEFAULT
  real*8,dimension(5) :: param
 
  param(:) = 0
  if (iargc() .lt. 4) then
    print*,"Missing parameter"
    return
  endif

  call getarg(1, arg)
  read( arg, * ) simu_id ! simulation id
  call getarg(2, arg)
  read( arg, * ) coupling ! coupling method

  do n=3, 7
    if(iargc() .ge. n) then
      call getarg(n, arg)
      read( arg, * ) param(n-2)
    endif
  enddo
        </code></pre>
        
        
        
<!--         <span class="mpi"> -->
        <p>
        In general, if all the simulations in a Sobol' group can easily be launched in a single MPMD MPI call, we can use the "<code class="code">MELISSA_COUPLING_MPI</code>" coupling mechanism.
        Links between simulations will be MPI communications in that case.
        Otherwise, if the simulation relies on MPI_COMM_WORLD for MPI routines or is not MPI at all, simulations have to be connected via ZeroMQ. This is the default coupling mechanism, called "<code class="code">MELISSA_COUPLING_ZMQ</code>".<br />
        A third coupling mechanism is also available if you have the FlowVR software installed in your environment. It is called "<code class="code">MELISSA_COUPLING_FLOWVR</code>", and we will not use it in this example.<br />
        In the heat solver, we can easily split MPI communicator, so we will use "<code class="code">MELISSA_COUPLING_MPI</code>".
        
        Split MPI_COMM_WORLD by simulation in the simulation group:
        <pre class="prettyprint c"><code class="lang-c">
  int *appnum, info;
  MPI_Comm_get_attr(MPI_COMM_WORLD, MPI_APPNUM, &appnum, &info);
  MPI_Comm_split(MPI_COMM_WORLD, *appnum, me, &comm);
        </code></pre>
        <pre class="prettyprint f"><code class="lang-fortran">
  integer(kind=MPI_ADDRESS_KIND) :: appnum
  integer :: info
  call MPI_Comm_get_attr(MPI_COMM_WORLD, MPI_APPNUM, appnum, info);
  call MPI_Comm_split(MPI_COMM_WORLD, appnum, me, comm, info);
        </code></pre>
<!--         </span> -->
        
        </P>
        
        
        
        We also need to give a "name" to the computed field. It must be the same name you will put in <code class="prettyprint lang-python">STUDY_OPTIONS['field_names']</code>.
        <pre class="prettyprint c"><code class="lang-c">
  char *field_name = "heat1";
        </code></pre>
        <pre class="prettyprint f mpi"><code class="lang-fortran">
  character(len=5) :: name = C_CHAR_"heat1"
        </code></pre>
        
        The first Melissa function can be called before the main <code class="code">for</code> loop.
        It has to be called exactly once <span class="mpi"> by process and</span> by field.
        <span class="c">For Fortran compatibility, we have to pass the arguments by reference.</span>
        <span class="mpi">It takes seven arguments:</span>
        <span class="nompi">It takes tree arguments:</span>
        <ul>
          <li><code class="code">field_name</code>: the unique name of the field to send</li>
          <li><code class="code">vect_size</code>: the size of the local result vector</li>
          <span class="mpi"><li><code class="code">np</code>: the size of the local MPI communicator</li></span>
          <span class="mpi"><li><code class="code">me</code>: the process rank in the local MPI communicator</li></span>
          <span><li><code class="code">simu_id</code>: the ID of the simulation in the study</li></span>
          <span class="mpi"><li><code class="code">comm</code>: the local MPI communicator</li></span>
          <li><code class="code">coupling</code>: the coupling variable</li>
        </ul>
        <pre class="prettyprint c mpi"><code class="lang-c">
  melissa_init(field_name, &vect_size, &np, &me, &simu_id, &comm, &coupling);
        </code></pre>
        <pre class="prettyprint f mpi"><code class="lang-fortran">
  call melissa_init(field_name, vect_size, np, me, simu_id, comm, coupling)
        </code></pre>
        <pre class="prettyprint c nompi"><code class="lang-c">
  melissa_init_no_mpi(field_name, &vect_size, &simu_id);
        </code></pre>
        <pre class="prettyprint f nompi"><code class="lang-fortran">
  call melissa_init_no_mpi(field_name, vect_size, simu_id)
        </code></pre>
        Inside the main loop, the result vector is updated by the <code class="code">conjgrad</code> function.
        Send this updated vector to Melissa Server by calling <span class="mpi"><code class="code">melissa_send</code></span><span class="nompi"><code class="code">melissa_send_no_mpi</code></span> right after the <code class="code">conjgrad</code> function.
        <span class="mpi">This function takes six arguments:</span>
        <span class="nompi">This function takes five arguments:</span>
        <ul>
          <li><code class="code">n</code>: the current iteration number</li>
          <li><code class="code">field_name</code>: the name of the field sent</li>
          <li><code class="code">u</code>: the vector to send to Melissa Server</li>
          <span class="mpi"><li><code class="code">me</code>: the process rank in the local MPI communicator</li></span>
          <li><code class="code">simu_id</code>: the ID of the simulation in the study</li>
        </ul>
        <pre class="prettyprint c mpi"><code class="lang-c">
  conjgrad (&a[0], &f[0], &u[0], &nx, &ny, &epsilon, &i1, &in, &np,
            &me, &next, &previous, &fcomm);
  melissa_send (&n, field_name, u, &me, &simu_id);
        </code></pre>
        <pre class="prettyprint f mpi"><code class="lang-fortran">
  call conjgrad(A, F, U, nx, ny, epsilon, i1, in, np, me, next, previous, comm)
  call melissa_send(n, name, u, me, simu_id)
        </code></pre>
        <pre class="prettyprint c nompi"><code class="lang-c">
  conjgrad (&a[0], &f[0], &u[0], &nx, &ny, &epsilon);
  melissa_send_no_mpi(&n, field_name, u, &simu_id);
        </code></pre>
        <pre class="prettyprint f nompi"><code class="lang-fortran">
  call conjgrad(A, F, U, nx, ny, epsilon)
  call melissa_send_no_mpi(n, name, u, simu_id)
        </code></pre>
        After the main loop, call <code class="code">melissa_finalize</code> to free Melissa structures and disconnect the simulations from the server.
        This function does not take any argument.
        <pre class="prettyprint c"><code class="lang-c">
  melissa_finalize();
        </code></pre>
        <pre class="prettyprint f"><code class="lang-fortran">
  call melissa_finalize()
        </code></pre>
        
        Link the code to the <code class="code">melissa_api</code> library, and compile it.
      </p>
        
     
     
      <h3 id="run">Launcher options</h3>
      
      <p>
      In this section, we will use the options_base.py file available in <code class="prettyprint lang-bash">install/share/examples/heat_example</code>. At the end, we should obtain something close to the reference option.py file present in the same directory. <br />
      as described in the <a class="" href="#launcher">Melissa Launcher section</a>, this file must contain all the material needed by the launcher to handle the study.
      </p>
     
      <p>
      First, define all the values of the dictionaries <code class="prettyprint lang-python">STUDY_OPTIONS</code> and <code class="prettyprint lang-python">MELISSA_STATS</code>. Then, we will define at least the mandatory user functions.
      </p>
     
      <p>
      The first one is <code class="prettyprint lang-python">USER_FUNCTIONS['draw_parameter_set']</code>. It must return a Numpy array of parameter, of size <code class="prettyprint lang-python">STUDY_OPTIONS['nb_parameters']</code>. It is used to draw the parameter sets of the simulations.<br />
      </p>
     
      <p>
      The second one is <code class="prettyprint lang-python">USER_FUNCTIONS['launch_server']</code>. It takes a <code class="prettyprint lang-python">server</code> object as an argument, ans must set a job ID in the <code class="prettyprint lang-python">job_id</code> attribute of this object.
      The <code class="prettyprint lang-python">server</code> object has two most useful attributes, set by Melissa Launcher:
      <ul>
      <li><code class="prettyprint lang-python">path</code>: the path to the Melissa Server executable</li>
      <li><code class="prettyprint lang-python">cmd_opt</code>: the command line options to passs to Melissa Server.</li>
      </ul>
      On a cluster, you will call the batch script to launch the server. In that case, you will need to set the command in your script, call it from this function, and get the job ID.<br/>
      In your local machine, the job ID would be the PID of the main process. It should look like that:
        <pre class="prettyprint mpi"><code class="lang-python">
  def launch_server(server):
      server.job_id = subprocess.Popen(('mpirun ' +
                                        server.path +
                                        '/melissa_server ' +
                                        server.cmd_opt +
                                        ' &').split()).pid
        </code></pre>
        <pre class="prettyprint nompi"><code class="lang-python">
  def launch_server(server):
      server.job_id = subprocess.Popen((server.path +
                                        '/melissa_server ' +
                                        server.cmd_opt +
                                        ' &').split()).pid
        </code></pre>
        
      </p>
      <p>
      The next function to define is <code class="prettyprint lang-python">USER_FUNCTIONS['launch_group']</code>. It is used to launch simulations (or groups of simulatioin the case of Sobol' indices computation). It takes a <code class="prettyprint lang-python">group</code> object as argument, and must set the job ID of the simulation (or group of simulations) in the attribute <code class="prettyprint lang-python">job_id</code> of the <code class="prettyprint lang-python">group</code> object. This object has three important attributes:
      <ul>
      <li><code class="prettyprint lang-python">simu_id</code></li>
      <li><code class="prettyprint lang-python">rank</code></li>
      <li><code class="prettyprint lang-python">param_set</code></li>
      </ul>
      We distinguish two kinds of groups:
      <ul>
      <li>Single simulation group (general case): Every simulation has its own job. In this case, <code class="prettyprint lang-python">simu_id</code> and <code class="prettyprint lang-python">rank</code> are equivalents, and <code class="prettyprint lang-python">param_set</code> is a numpy array of size <code class="prettyprint lang-python">STUDY_OPTIONS['nb_parameters']</code>.</li>
      <li>Sobol group: In the case of Sobol' indices computation, all the simulations of a Sobol' group must be in the same job. In that case, <code class="prettyprint lang-python">simu_id</code> is a list of the simulation IDs inside the Sobol' group (the ones you will pass to <code class="prettyprint lang-c">melissa_init</code>), and <code class="prettyprint lang-python">rank</code> is the ID of the group. param_set is a list of size <code class="prettyprint lang-python">STUDY_OPTIONS['nb_parameters'] + 2</code> of numpy arrays of size <code class="prettyprint lang-python">STUDY_OPTIONS['nb_parameters']</code>, corresponding to the n+2 sets of n parameters of the n+2 simulations of the Sobol' group.</li>
      </ul>
      </p>
     
      <p>
      Once we have set the job IDs of our jobs, we can use it to define the fault tolerance functions. In our case, we will use the same function for the server and the simulations. It takes a <code class="prettyprint lang-python">Job</code> object as argument, and sets its <code class="prettyprint lang-python">status</code> attribute to 0 if it is waiting to be scheduled, 1 if it is currently running, or 2 if it is not running anymore.
      In your local machine, a job will never be have a 0 <code class="prettyprint lang-python">status</code>, because it is launched immediately when <code class="prettyprint lang-python">USER_FUNCTIONS['launch_group']</code> is called.
      </p>
      <p>
      <code class="prettyprint lang-python">USER_FUNCTIONS['cancel_job']</code> kills a given job. It takes a <code class="prettyprint lang-python">Job</code> object in argument, and uses its attribute <code class="prettyprint lang-python">job_id</code> to kill or cancel it. It does not return anything.
      </p>
      <p>
      Examples of all theses functions can be found in the file <code class="prettyprint lang-bash">install/share/examples/heat_example/scripts/options_local.py</code>.
      Remember that your option file must be called <code class="prettyprint lang-bash">options.py</code>.
      </p>
     
      <h3 id="run">Run the study</h3>
      
      <p>
        To run a study with the heat equation solver, call the launcher with the path to your <code class="code">options.py</code> file:
        <pre class="prettyprint"><code class="lang-bash">
  melissa_launcher .
        </code></pre>
        The results will be in the directory <code class="code">STATS</code>, in files of the form: <code class="code">&#60field_name&#62_&#60stat&#62.&#60time_stamp&#62</code><br />
        For example, the variance of the field "heat" at the first timestep whould be: <code class="code">heat_variance.001</code>
      </p>
<!--          <h2 id="dox">Refman generated by Doxygen </h1><hr/>
               <p>
               </p>
             <iframe title="Doxygen" src="doxygen/index.html"></iframe>-->
             
      <h2 id="dox">Refman generated by Doxygen </h1><hr/>
        <p>
        </p>
        <iframe title="Doxygen" src="doxygen/index.html"></iframe>
          </section>
        </div>

      <script>
        <!--
        var my_on_click = 0;
        
        function rendre_actif(element)
        {
            document.querySelector(".active").className = "";
            document.querySelector('a[href="#' + element + '"]').className = "active";
        }

        document.onscroll = function(){
            if(my_on_click ==1)
            {
                my_on_click = 0;
            }
            else
            {
                var scroll = window.scrollY;
                if(scroll >= document.getElementById("dox").offsetTop - 10)
                {
                    rendre_actif("dox");
                }
                else if(scroll >= document.getElementById("sbs").offsetTop - 10)
                {
                    rendre_actif("sbs");
                }
                else if(scroll >= document.getElementById("launcher").offsetTop - 10)
                {
                    rendre_actif("launcher");
                }
                else if(scroll >= document.getElementById("simu").offsetTop - 10)
                {
                    rendre_actif("simu");
                }
                else if(scroll >= document.getElementById("api").offsetTop - 10)
                {
                    rendre_actif("api");
                }
                else if(scroll >= document.getElementById("intro").offsetTop - 10)
                {
                    rendre_actif("intro");
                }
            }
        }
        
        document.querySelector('a[href="#sbs"]').onclick = function() {
            my_on_click =1;
            rendre_actif("dox");
        }
          
        document.querySelector('a[href="#sbs"]').onclick = function() {
            my_on_click =1;
            rendre_actif("sbs");
        }
          
        document.querySelector('a[href="#launcher"]').onclick = function() {
            my_on_click =1;
            rendre_actif("launcher");
        }
        
        document.querySelector('a[href="#simu"]').onclick = function() {
            my_on_click =1;
            rendre_actif("simu");
        }
        
        document.querySelector('a[href="#api"]').onclick = function() {
            my_on_click =1;
            rendre_actif("api");
        }
        
        document.querySelector('a[href="#intro"]').onclick = function() {
            my_on_click =1;
            rendre_actif("intro");
        }
        
        var par = document.querySelector('input[name="MPI"]:checked').value;
        var lang = document.querySelector('input[name="lang"]:checked').value;
       
        var element1 = document.getElementById('par');
        element1.addEventListener('change', plop );
        var element2 = document.getElementById('lang');
        element2.addEventListener('change', plop );
       
        function plop()
        {
            par = document.querySelector('input[name="MPI"]:checked').value;
            lang = document.querySelector('input[name="lang"]:checked').value;
            var i, blocks;
            blocks = document.getElementsByClassName('c');
            for (i = 0; i < blocks.length ; i++)
            {
                blocks[i].style.display = '';
            }
            blocks = document.getElementsByClassName('f');
            for (i = 0; i < blocks.length ; i++)
            {
                blocks[i].style.display = '';
            }
            blocks = document.getElementsByClassName('mpi');
            for (i = 0; i < blocks.length ; i++)
            {
                blocks[i].style.display = '';
            }
            blocks = document.getElementsByClassName('nompi');
            for (i = 0; i < blocks.length ; i++)
            {
                blocks[i].style.display = '';
            }
            blocks = document.getElementsByClassName(par);
            for (i = 0; i < blocks.length ; i++)
            {
                blocks[i].style.display = 'none';
            }
            blocks = document.getElementsByClassName(lang);
            for (i = 0; i < blocks.length ; i++)
            {
                blocks[i].style.display = 'none';
            }
        }
        plop();
          //-->
      </script>
    </body>
</html>
