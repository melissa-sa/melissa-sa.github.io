
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <link href="prettify.css" type="text/css" rel="stylesheet" />
    <script type="text/javascript" src="prettify.js"></script>
    <link rel="stylesheet" href="melissa.css" />

    <title>Melissa</title>
  </head>

  <body onload="prettyPrint()">
    <div id="titlearea">
      <table cellspacing="0" cellpadding="0">
        <tbody>
          <tr style="height: 56px;">
            <td style="padding-left: 0.5em;">
              <div id="melissa">
                Melissa
              </div>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
    <div id="navrow1" class="tabs">
      <ul class="tablist">
        <li><a href="index.html"><span>Main&#160;Page</span></a></li>
        <li class="current"><a href="tutorial.html"><span>Getting Started</span></a></li>
        <li><a href="refcard.html"><span>Refcard</span></a></li>
        <li><a href="doxygen.html"><span>Doxygen</span></a></li>
        <li><a href="https://github.com/melissa-sa/melissa" target="_blank"><span>Source</span></a></li>
      </ul>
    </div>
    <div id="nav-path" class="navpath">
      <ul>
        <li class="navelem"><a class="el" href="start.html"><button id="start" type="button">Get the Software</button></a></li>
        <li class="navelem"><a class="el" href="install.html"><button id="install" type="button">Install</button></a></li>
        <li class="navelem_current"><a class="el" href="tutorial.html"><button id="tuto" type="button">Step-by-step Tutorial</button></a></li>
      </ul>
    </div>
    <div class="header">
      <div class="headertitle">
        <div class="title">
          Tutorial
        </div>
        <p>
          Step-by-step with the heat equation solver
        </p>
        <a href="install.html"><button id="prev" type="button">previous</button></a><button id="next" type="button">next</button>
        <script>
          document.getElementById('next').style.visibility="hidden";
        </script>
      </div>
    </div><!--header-->
 
    <div id="tuto_text" class="text">
      <h2>Overview</h2>
      <p>
        In this section, we will use Melissa to perform a global sensitivity analysis on a very simple case: a heat equation solver.<br />
        This example is available on the folder <code class="code">source/examples/heat_example</code>.
        It solves the heat equation on a regular 2D grid, with backward Euler method.<br />
        The original source codes are <code class="code">heat_base.c</code> in C and <code class="code">heat_base.f90</code> in Fortran.<br />
        We will go through Melissa integration step by step in these examples.
        The final results are available in <code class="code">heat.c</code>, <code class="code">heat.f90</code> and <code class="code">options.py</code>. They are compiled with Melissa if the option <code class="code">-DBUILD_EXAMPLES=ON</code> is given to CMake.<br />
        Select your simulation type and language:
      </p>
<!--       <form method="post" action="traitement.php"> -->
      <fieldset id="par">
        <legend>Simulation type</legend> <!-- Titre du fieldset -->
        <p>
          <input type="radio" name="MPI" value="nompi" id="MPI" checked/> <label for="MPI">MPI    </label><br />
          <input type="radio" name="MPI" value="mpi" id="noMPI" /> <label for="noMPI">No MPI</label><br />
        </p>
      </fieldset>
      <fieldset id="lang">
        <legend>Simulation language</legend> <!-- Titre du fieldset -->
        <p>
          <input type="radio" name="lang" value="f" id="C" checked/> <label for="C">C</label><br />
          <input type="radio" name="lang" value="c" id="Fortran" /> <label for="Fortran">Fortran</label><br />
        </p>
      </fieldset>
      <p>
      The grid is a 10 by 10 square with 100 subdivisions on each axis. The solver takes options from the command line.
      The first option is the initial temperature. It is mandatory. The four next ones are the four borders temperatures (Dirichlet boundary conditions). They are optional, and are set to zero if not defined.<br />
      For example, with an initial temperature of 10 and boundary conditions of 5:
      
        <pre class="prettyprint c mpi"><code class="lang-bash">
  mpirun ./heatc_base 10 5 5 5 5
        </code></pre>
        <pre class="prettyprint c nompi"><code class="lang-bash">
  ./heatc_base 10 5 5 5 5
        </code></pre>
        <pre class="prettyprint f mpi"><code class="lang-bash">
  mpirun ./heatf_base 10 5 5 5 5
        </code></pre>
        <pre class="prettyprint f nompi"><code class="lang-bash">
  ./heatf_base 10 5 5 5 5
        </code></pre>
      
      
      <p/>
<!--       </form> -->
      <h2>Melissa API</h2>
      <p>
        To use the heat equation solver with Melissa, we first have to define a way to pass the parameter sample ID and the Sobol rank to the simulation code.
        Melissa will need it to identify which simulation sent the data.
        In our case, we will do that by adding arguments to the command line.<br />
        We first store the sample ID and the Sobol's rank of the simulation in two integers.
        The solver can then take from one to five input parameters, so we store them in five doubles.
       
        <pre class="prettyprint c"><code class="lang-c">
  int sample_id = 0;
  int sobol_rank = 0;
  double param[5];

  if (argc < 4)
  {
      fprintf (stderr, "Missing parameter");
      return -1;
  }
  sobol_rank = (int)strtol(argv[1], NULL, 10); // sobol rank
  sample_id = (int)strtol(argv[2], NULL, 10); // sobol group
  param[0] = strtod(argv[3], NULL); // initial temperature

  for (n=0; n<4; n++)
  {
    param[n+1] = param[0];
    if (argc > n+4)
    {
       param[n+1] = strtod(argv[n+4], NULL);
    }
  }
        </code></pre>
       
        <pre class="prettyprint f"><code class="lang-fortran">
  integer :: sample_id = 0
  integer :: sobol_rank = 0
  real*8,dimension(5) :: param
 
  if (iargc() .lt. 4) then
    print*,"Missing parameter"
    return
  endif

  call getarg(1, arg)
  read( arg, * ) sobol_rank ! sobol rank
  call getarg(2, arg)
  read( arg, * ) sample_id ! sobol group
  call getarg(3, arg)
  read( arg, * ) param(1) ! initial temperature
  param(:) = param(1)

  do n=5, 8
    if(iargc() .ge. n) then
      call getarg(n-1, arg)
      read( arg, * ) param(n-3)
    endif
  enddo
        </code></pre>
        <span class="mpi">
        In the case of Sobol's indices computation, one must define the way simulations are connected inside a group.
        If all the simulations in a Sobol's group can easily be launched in a single MPMD MPI call, we can define a "coupled" group.
        Links between simulations will be MPI communications in that case.
        Otherwise, if the simulation relies on MPI_COMM_WORLD for MPI routines or is not MPI at all, simulations have to be connected via ZeroMQ.
        This is called the "not coupled" case.<br />
        In the heat solver, we can easily split MPI communicator, so we will use a coupled case.
        Define a new integer variable, with a value of <code class="code">1</code>:
        <pre class="prettyprint c"><code class="lang-c">
  int coupling = 1;
        </code></pre>
        <pre class="prettyprint f"><code class="lang-fortran">
  integer :: coupling = 1
        </code></pre>
        </span>
        To use the Melissa functions, one have to include <code class="code">melissa_api<span class="f">.f90</span><span class="c nompi">_no_mpi.h</span><span class="c mpi">.h</span></code> at the begining of the code.
        <pre class="prettyprint c mpi"><code class="lang-c">
  #include &#60melissa_api.h&#62
        </code></pre>
        <pre class="prettyprint c nompi"><code class="lang-c">
  #include &#60melissa_api_no_mpi.h&#62
        </code></pre>
        <pre class="prettyprint f"><code class="lang-fortran">
  include "melissa_api.f90"
        </code></pre>
        The first Melissa function can be called before the main <code class="code">for</code> loop.
        It has to be called exactly once <span class="mpi"> by every process</span>.
        <span class="mpi">It takes seven arguments:</span>
        <span class="nompi">It takes tree arguments:</span>
        <ul>
          <li><code class="code">vect_size</code>: the size of the local result vector</li>
          <span class="mpi"><li><code class="code">np</code>: the size of the local MPI communicator</li></span>
          <span class="mpi"><li><code class="code">me</code>: the process rank in the local MPI communicator</li></span>
          <li><code class="code">sobol_rank</code>: the rank of the simulation in the Sobol' group</li>
          <span class="mpi"><li><code class="code">sample_id</code>: the ID of the group in the study</li></span>
          <span class="mpi"><li><code class="code">comm</code>: the local MPI communicator</li></span>
          <li><code class="code">coupling</code>: the coupling variable</li>
        </ul>
        <pre class="prettyprint c mpi"><code class="lang-c">
  melissa_init(&vect_size, &np, &me, &sobol_rank, &sample_id, &comm, &coupling);
        </code></pre>
        <pre class="prettyprint f mpi"><code class="lang-fortran">
  call melissa_init(vect_size, np, me, sobol_rank, sample_id, comm, coupling)
        </code></pre>
        <pre class="prettyprint c nompi"><code class="lang-c">
  melissa_init_no_mpi(&vect_size, &sobol_rank, &sample_id);
        </code></pre>
        <pre class="prettyprint f nompi"><code class="lang-fortran">
  call melissa_init_no_mpi(vect_size, sobol_rank, sample_id)
        </code></pre>
        Inside the main loop, the result vector is updated by the <code class="code">conjgrad</code> function.
        Send this updated vector to Melissa Server by calling <span class="mpi"><code class="code">melissa_send</code></span><span class="nompi"><code class="code">melissa_send_no_mpi</code></span> right after the <code class="code">conjgrad</code> function.
        <span class="mpi">This function takes six arguments:</span>
        <span class="nompi">This function takes five arguments:</span>
        <ul>
          <li><code class="code">n</code>: the current iteration number</li>
          <li><code class="code">field_name</code>: the name of the field sent</li>
          <li><code class="code">u</code>: the vector to send to Melissa Server</li>
          <span class="mpi"><li><code class="code">me</code>: the process rank in the local MPI communicator</li></span>
          <li><code class="code">sobol_rank</code>: the rank of the simulation in the Sobol' group</li>
          <li><code class="code">sample_id</code>: the ID of the group in the study</li>
        </ul>
        <pre class="prettyprint c mpi"><code class="lang-c">
  conjgrad (&a[0], &f[0], &u[0], &nx, &ny, &epsilon, &i1, &in, &np, &me, &next, &previous, &fcomm);
  melissa_send (&n, field_name, u, &me, &sobol_rank, &sample_id);
        </code></pre>
        <pre class="prettyprint f mpi"><code class="lang-fortran">
  call conjgrad(A, F, U, nx, ny, epsilon, i1, in, np, me, next, previous, comm)
  call melissa_send(n, name, u, me, sobol_rank, sample_id)
        </code></pre>
        <pre class="prettyprint c nompi"><code class="lang-c">
  conjgrad (&a[0], &f[0], &u[0], &nx, &ny, &epsilon);
  melissa_send_no_mpi(&n, field_name, u, &sobol_rank, &sample_id);
        </code></pre>
        <pre class="prettyprint f nompi"><code class="lang-fortran">
  call conjgrad(A, F, U, nx, ny, epsilon)
  call melissa_send_no_mpi(n, name, u, sobol_rank, sample_id)
        </code></pre>
        After the main loop, call <code class="code">melissa_finalize</code> to free Melissa structures and disconnect the simulations from the server.
        This function does not take any argument.
        <pre class="prettyprint c"><code class="lang-c">
  melissa_finalize();
        </code></pre>
        <pre class="prettyprint f"><code class="lang-fortran">
  call melissa_finalize()
        </code></pre>
        
        Link the code to the <code class="code">melissa_api</code> library, and compile it.
      </p>
     
      <h2>Melissa Launcher</h2>
      <p>
        Once the simulation is instrumented, Melissa Launcher needs to know how to handle the simulation jobs.<br />
        This is done by giving the launcher some functions and variables through a python file.
        The file must be called <code class="code">options.py</code>. Take <code class="code">launcher/options.py</code> as a base for this file.
        There are six sets of variables to define, as dictionaries.
        <ul>
          <li><code class="code">GLOBAL_OPTIONS</code>: contains informations about your environement.<br />
          <li><code class="code">STUDY_OPTIONS</code>: sets the parameters of your sensitivity study. They will be used by the launcher to generate its internal structures for the study management.</li>
          <li><code class="code">SERVER_OPTIONS</code> and <code class="code">SIMULATIONS_OPTIONS</code>: sets some parameters to launch the server and simulations jobs.</li>
          <li><code class="code">MELISSA_STATS</code>: are used to activate (or not) the computations of the iterative statistics.</li>
          <li><code class="code">USER_FUNCTIONS</code>: are pointers to user defined functions, used by the launcher. Some of them are optional, others are mandatory. We will describe these functions in this section.</li>
        </ul>
        Note that you can add fields to the option dictionaries, and they can be used in the user defined functions.
      </p>
      <h3>Functions</h3>
      Melissa Launcher needs the mandatory functions to be defined. Otherwhise, it will return without launching the study.
      The optional functions are ignored if they are not defined by the user.
      <ul>
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['create_study']</code> (optional):</pre></li>
        This function is called only once, before starting the study. It is called from the dirrectory set in <code class="prettyprint lang-python">GLOBAL_OPTIONS['working_directory']</code>. You can use this function to create a folder tree, copy files, compile code, etc.
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['draw_parameter_set']</code> (mandatory):</pre></li>
        This function is used by Melissa launcher to draw simulations parameter sets. it must return a Numpy array of floats of the size <code class="prettyprint lang-python">STUDY_OPTIONS['nb_parameters']</code>
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['create_group']</code> (optional):</pre></li>
        This function is called once for each group in the study, before launching the study. Its behavior is the same as <code class="prettyprint lang-python">USER_FUNCTIONS['create_study']</code>.
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['create_simulation']</code> (optional):</pre></li>
        This function is called once for each simulation in the study, before launching the study. Its behavior is the same as <code class="prettyprint lang-python">USER_FUNCTIONS['create_study']</code>.
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['launch_server']</code> (mandatory):</pre></li>
        Once every simulation, group and parameter set is defined, Melissa Launcher uses this function to launch Melissa Server. The function takes a <code class="code">Server</code> object for argument, and needs to set the server job ID in <code class="code">server.job_id</code>.
        On a cluster the job ID is given by the batch scheduller. In your local machine, you can use the process ID. The server command line options are in <code class="code">server.cmd_opt</code>, you should not modify it.<br />
        An example for a Slurm cluster:
        <pre class="prettyprint"><code class="lang-python">
  import subprocess

  def launch_server(server):
      os.chdir(GLOBAL_OPTIONS['working_directory'])
      
      # create a job script
      fichier=open("run_server.sh", "w")
      contenu  = "#!/bin/bash \n"
      contenu  = "# Example with Slurm \n"
      contenu += "#SBATCH -N 4 \n"
      contenu += "#SBATCH --job-name=Melissa_server \n"
      contenu += "mkdir stats${SLURM_JOB_ID}.resu \n"
      contenu += "cd stats${SLURM_JOB_ID}.resu \n"
      contenu += "mpirun "+server.path+"/server "+server.cmd_opt+" & \n"
      contenu += "wait %1 \n"
      contenu += "cd "+workdir+" \n"
      fichier.write(contenu)
      fichier.close()
      
      # run the job script
      proc = subprocess.Popen('sbatch "./run_server.sh"',
                              stdout=subprocess.PIPE,
                              stderr=subprocess.PIPE,
                              shell=True,
                              universal_newlines=True)
                              
      # get the job ID
      (out, err) = proc.communicate()
      server.job_id = out.split()[-1]

  USER_FUNCTIONS['launch_server'] = launch_server
        </code></pre>
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['launch_simulation']</code> (mandatory):</pre></li>
        This function is used to launch simulations. In the case of Sobol' indices computation, a group is considered as a simulation. The function takes a <code class="code">Simulation</code> object for argument, and needs to set the simulation job ID in <code class="code">simulation.job_id</code>.
        On a cluster the job ID is given by the batch scheduller. In your local machine, you can use the process ID.
        You have to copy the file called "server_name.txt" from the directory <code class="prettyprint lang-python">GLOBAL_OPTIONS['working_directory']</code> to the location where the simulation will run. The simulation will read it to retrieve the server node name in order to contact it.
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['check_server_job']</code> (mandatory):</pre></li>
        This function is called while the server is running. It checks the job's status in the scope of the fault tolerance mechanism.
        It takes a <code class="code">Job</code> object for argument, and needs to set <code class="code">job.job_status</code> to 1 if the job is still running, an to 2 otherwhise. A <code class="code">Server</code> object inherites from <code class="code">Job</code>, and the job ID is in <code class="code">job.job_id</code>.
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['check_simulation_job']</code> (mandatory):</pre></li>
        This function is called while a simulation is running. It checks the job's status in the scope of the fault tolerance mechanism.
        It takes a <code class="code">Job</code> object for argument, and needs to set <code class="code">job.job_status</code> to 1 if the job is still running, an to 2 otherwhise. A <code class="code">Simulation</code> object inherites from <code class="code">Job</code>, and the job ID is in <code class="code">job.job_id</code>.
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['cancel_job']</code> (mandatory):</pre></li>
        This function is calles by the launcher when a job have to be canceled. It takes a <code class="code">Job</code> object for argument, and kills it.
        The job ID is defined in <code class="code">job.job_id</code>.<br />
        An example with a Slurm job:
        <pre class="prettyprint"><code class="lang-python">
  import os
  
  def cancel_job(job):
      os.system('scancel '+job.job_id)
      
  USER_FUNCTIONS['cancel_job'] = cancel_job
        </code></pre>
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['restart_server']</code> (optional):</pre></li>
        This function have the same behavior as <code class="prettyprint lang-python">USER_FUNCTIONS['launch_server']</code>. It is used to reboot the server in the case of a fault. If it is not defined, Melissa Launcher uses the <code class="prettyprint lang-python">launch_server</code> function by default.
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['restart_simulation']</code> (optional):</pre></li>
        This function have the same behavior as <code class="prettyprint lang-python">USER_FUNCTIONS['launch_simulation']</code>. It is used to reboot a simulation (or a group of simulations) in the case of a fault. If it is not defined, Melissa Launcher uses the <code class="prettyprint lang-python">USER_FUNCTIONS['launch_simulation']</code> function by default.
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['check_scheduler_load']</code> (optional):</pre></li>
        Melissa Launcher calls this function right before launching each simulation job. You can make it block until you want to launch the next simulation.
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['postprocessing']</code> (optional):</pre>
        This function is called once at the end of the study. It does nothing by default.
        
        <li><pre><code class="prettyprint lang-python">USER_FUNCTIONS['finalize']</code> (optional):</pre></li>
        The same as <code  class="prettyprint lang-python">USER_FUNCTIONS['postprocessing']</code>.
      </ul>
      
      An example <code class="code">options.py</code> file is available in <code class="code">examples/heat_example</code>. Use it as a base to define your own <code class="code">options.py</code> file.
     
      <h2>Launch the study</h2>
      
      To launch a study with the heat equation solver, call the launcher with the path to your <code class="code">option.py</code> file:
        <pre class="prettyprint"><code class="lang-bash">
  cd examples/heat_example
  python ../../launcher/melissa_launcher ./
        </code></pre>
        
     
    </div>
    <script>
        <!--
        var par = document.querySelector('input[name="MPI"]:checked').value;
        var lang = document.querySelector('input[name="lang"]:checked').value;
       
        var element1 = document.getElementById('par');
        element1.addEventListener('change', plop );
        var element2 = document.getElementById('lang');
        element2.addEventListener('change', plop );
       
        function plop()
        {
            par = document.querySelector('input[name="MPI"]:checked').value;
            lang = document.querySelector('input[name="lang"]:checked').value;
            var i, blocks;
            blocks = document.getElementsByClassName('c');
            for (i = 0; i < blocks.length ; i++)
            {
                blocks[i].style.display = '';
            }
            blocks = document.getElementsByClassName('f');
            for (i = 0; i < blocks.length ; i++)
            {
                blocks[i].style.display = '';
            }
            blocks = document.getElementsByClassName('mpi');
            for (i = 0; i < blocks.length ; i++)
            {
                blocks[i].style.display = '';
            }
            blocks = document.getElementsByClassName('nompi');
            for (i = 0; i < blocks.length ; i++)
            {
                blocks[i].style.display = '';
            }
            blocks = document.getElementsByClassName(par);
            for (i = 0; i < blocks.length ; i++)
            {
                blocks[i].style.display = 'none';
            }
            blocks = document.getElementsByClassName(lang);
            for (i = 0; i < blocks.length ; i++)
            {
                blocks[i].style.display = 'none';
            }
        }
        plop();
        //-->
    </script>
  </body>
</html>
